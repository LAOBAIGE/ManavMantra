%InputFutureMap
% A map from closure dependencies to closure input future that can be used
% by the data processor instances to map data from dependencies into inputs
% required for the operation.
%

%   Copyright 2015-2017 The MathWorks, Inc.

classdef (Sealed) InputFutureMap < handle
    properties (SetAccess = immutable)
        % The number of upstream dependencies expected to be passed to the
        % associated data processor.
        NumDependencies;
        
        % The number of operation inputs that will be generated by applying
        % this map to dependency inputs.
        NumOperationInputs;
        
        % The index of each function handle input into the list of
        % ExecutionTask inputs.
        InputIndices;
        
        % For each input this is the index into the multiplexed
        % ExecutionTask input.
        ArgoutIndices;
    end
    
    methods (Static)
        % Create a InputFutureMap using the provided ordered list of input
        % futures and ordered list of closure dependencies.
        function [obj, additionalConstants] = createFromClosures(inputFutures, dependencyClosures)
            import matlab.bigdata.internal.lazyeval.InputFutureMap;
            numOperationInputs = numel(inputFutures);
            additionalConstants = {};
            if numOperationInputs == 0
                obj = InputFutureMap([], [], numel(dependencyClosures));
                return;
            end
            
            inputIndices = zeros(1, numOperationInputs);
            multiplexIndices = zeros(1, numOperationInputs);
            
            inputPromises = [inputFutures.Promise];
            isInputDone = [inputFutures.IsDone];
            
            if any(~isInputDone)
                [~, indices] = ismember([inputPromises(~isInputDone).Closure], dependencyClosures);
                inputIndices(~isInputDone) = indices;
                multiplexIndices(~isInputDone) = [inputPromises(~isInputDone).ArgoutIndex];
            end
            
            numDependencies = numel(dependencyClosures);
            if any(isInputDone)
                additionalConstants = {inputFutures(isInputDone).Value};
                inputIndices(isInputDone) = numel(dependencyClosures) + 1;
                multiplexIndices(isInputDone) = 1:nnz(isInputDone);
                numDependencies = numDependencies + 1;
            end
            
            obj = InputFutureMap(inputIndices, multiplexIndices, numDependencies);
        end
        
        % Create an InputFutureMap that expects only a single upstream
        % dependency, which maps each varargout output of that single
        % upstream dependency to an operation input.
        function obj = createPassthrough(numVariables)
            import matlab.bigdata.internal.lazyeval.InputFutureMap;
            
            dependencyIndices = zeros(1, numVariables);
            multiplexIndices = zeros(1, numVariables);
            lastIndex = 0;
            for ii = 1:numel(numVariables)
                indices = lastIndex + (1:numVariables(ii));
                lastIndex = lastIndex + numVariables(ii);
                dependencyIndices(indices) = ii;
                multiplexIndices(indices) = 1:numVariables(ii);
            end
            
            numDependencies = numel(numVariables);
            obj = InputFutureMap(dependencyIndices, multiplexIndices, numDependencies);
        end
    end
    
    methods
        % Map data received from the upstream dependencies into the inputs
        % to be provided for each operation input.
        function operationInputs = mapData(obj, inputsFromDependencies)
            operationInputs = cell(size(obj.InputIndices));
            
            for ii = 1:numel(operationInputs)
                operationInputs{ii} = inputsFromDependencies{obj.InputIndices(ii)}(:, obj.ArgoutIndices(ii));
            end
        end
        
        % Map an array of scalars with one per upstream dependencies, into
        % an array of scalars with one per operation input.
        function out = mapScalars(obj, in)
            out = in(obj.InputIndices);
        end
        
        % Map an array of logicals with one per operation input, into an
        % array of logicals with one per upstream dependency. This applies
        % the any operation whenever an upstream dependency maps to
        % multiple operation inputs.
        function out = reverseMapLogicals(obj, in)
            out = accumarray(obj.InputIndices(:), in(:), [obj.NumDependencies, 1], @any);
        end
        
        % Retrieve a map that represents a sub-selection of function input
        % indices. If the dependencies are provided, this will also discard
        % dependencies that are not required.
        function [map, dependencies] = submap(obj, functionInputIndices, dependencies)
            import matlab.bigdata.internal.lazyeval.InputFutureMap;
            
            inputIndices = obj.InputIndices(functionInputIndices);
            argoutIndices = obj.ArgoutIndices(functionInputIndices);
            numDependencies = obj.NumDependencies;
            
            if nargin >= 3
                [uniqueDependencyIndices, ~, inputIndices] = unique(inputIndices);
                dependencies = dependencies(uniqueDependencyIndices);
                numDependencies = numel(dependencies);
            end
            
            map = InputFutureMap(inputIndices, argoutIndices, numDependencies);
        end
        
        % Refactor such that the requested dependencies are pulled into a
        % second InputFutureMap.
        %
        % This allows us to insert a new operation in-between a closure
        % and its inputs at the point where back-end work is being
        % scheduled.
        %
        % Syntax:
        %   [map, preMap] = factorOutDependencies(map, dependenciesToPullOut);
        %
        % Where:
        %   - preMap is a map from the dependencies specified by
        %   dependenciesToPullOut to the unique operation inputs from said
        %   dependencies.
        %
        %   - map is refactored to be dependent on preMap in combination
        %   with all other dependencies not pulled out.
        %
        % For example, suppose an operation had 3 dependencies. It requires
        % to insert an all to one operation for inputs from dependencies 1
        % and 3. This can be done with:
        %
        %   % Pull out dependencies 1 and 3 from InputFutureMap.
        %   [map,preMap] = factorOutDependencies(map,[1,3]);
        %
        %   % Then create a back-end task that represents the prework (all
        %   % to one communication). This must be given the corresponding
        %   %  task objects for dependencies 1 and 3. The underlying
        %   % processor will be given each and every input variable
        %   % originating from dependencies 1 and 3. It must emit the same
        %   % number of output variables.
        %   preProcessorFactory = PassthroughProcessor.createFactory();
        %   preProcessorFactory = InputMapProcessorDecorator(preProcessorFactory, preMap);
        %   preTask = ExecutionTask.createAllToOne(predecessorTasks([1,3]), preProcessorFactory);
        %
        %   % Finally, create the task for the original operation, wrapping
        %   % it using the refactored task and passing it all remaining
        %   % dependency task objects in combination with the preTask. The
        %   % preTask output must be given last. This will receive all
        %   % input variables in the same order as before.
        %   processorFactory = MyProcessor.createFactory();
        %   processorFactory = InputMapProcessorDecorator(processorFactory, map);
        %   task = ExecutionTask.createSimple([predecessorTasks(2); preTask], processorFactory);
        %
        % TODO(g1590575): This will be made obsolete by improvements at the
        % optimizer layer. It should be removed at that point.
        %
        function [map, preMap] = factorOutDependencies(map, dependenciesToPullOut)
            import matlab.bigdata.internal.lazyeval.InputFutureMap;
            assert(isnumeric(dependenciesToPullOut));
            
            [isPreOpInput, preOpInputDependencies] = ismember(map.InputIndices, dependenciesToPullOut);
            preOpInputDependencies = preOpInputDependencies(isPreOpInput);
            preOpInputArgouts = map.ArgoutIndices(isPreOpInput);
            % This unique is to prevent the pre-operation from receiving
            % duplicate inputs. This prevents copying more data than is
            % necessary.
            [preOpInputDependencies, preOpInputArgouts, ~, preOpUniqueIdx] = ...
                iPairUnique(preOpInputDependencies, preOpInputArgouts);
            preMap = InputFutureMap(preOpInputDependencies, preOpInputArgouts, numel(dependenciesToPullOut));
            
            dependenciesToKeep = setdiff(1 : map.NumDependencies, dependenciesToPullOut);
            [~, opInputDependencies] = ismember(map.InputIndices, dependenciesToKeep);
            opInputArgouts = map.ArgoutIndices;
            % These opInputs are now piped through the preMap, which will
            % be passed into this map as the last dependency.
            opInputDependencies(isPreOpInput) = numel(dependenciesToKeep) + 1;
            opInputArgouts(isPreOpInput) = preOpUniqueIdx;
            map = InputFutureMap(opInputDependencies, opInputArgouts, numel(dependenciesToKeep) + 1);
        end
    end
    
    methods (Access = private)
        % The main constructor.
        function obj = InputFutureMap(inputIndices, multiplexIndices, numDependencies)
            obj.NumDependencies = numDependencies;
            obj.NumOperationInputs = numel(inputIndices);
            obj.InputIndices = inputIndices(:)';
            obj.ArgoutIndices = multiplexIndices(:)';
        end
    end
end

function [x,y,varargout] = iPairUnique(x,y)
% Get the unique pairs of values from arrays x and y.
data = [x(:), y(:)];
[data, varargout{1 : nargout - 2}] = unique(data, 'rows');
x = data(:, 1);
y = data(:, 2);
end
