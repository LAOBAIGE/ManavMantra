function varargout = splitapply(fun,varargin)
%SPLITAPPLY Split data into groups and apply function
%   Y = SPLITAPPLY(FUN,X,G)
%   Y = SPLITAPPLY(FUN,X1,X2,...,G)
%   [Y1,Y2,...] = SPLITAPPLY(FUN,...)
%
%   Limitations:
%   FUN must not rely on any state such as PERSISTENT data or random number
%   generating functions such as RAND.
%
%   See also FINDGROUPS

%   Copyright 2016-2017 The MathWorks, Inc.

narginchk(3,inf);
tall.checkNotTall(upper(mfilename), 0, fun);
if ~isa(fun, 'function_handle')
    error(message('MATLAB:splitapply:InvalidFunction'));
end

if ~all(cellfun(@istall, varargin))
    error(message('MATLAB:bigdata:array:AllArgsTall', upper(mfilename)));
end

gnum = varargin{end};
dataInputs = varargin(1 : end - 1);

gnum = tall.validateType(gnum, upper(mfilename), {'numeric'}, nargin);

% This exists so that a scalar gnum is expanded to the full length. We need
% to do this as bykey and filter do not support singleton expansion.
% Further, this converts gnum to a categorical so that grouped operations
% can use the categories to determine the known groups instead unique of
% of the each chunk.
[dataInputs{:}] = validateSameTallSize(dataInputs{:});
gnum = slicefun(@iExtractGnumAsDouble, dataInputs{:}, gnum);
gnum.Adaptor = setSmallSizes(matlab.bigdata.internal.adaptors.getAdaptorForType('double'), 1);

% This guards against the case where gnum was tall but all data input
% arguments were each a single row. We do this after expanding gnum because
% as above, scalar gnum is supported but data inputs must be full height.
[dataInputs{:}, gnum] = validateSameTallSize(dataInputs{:}, gnum);

% This is to support the syntax splitapply(fun, table(..), gnum)
dataInputs = iFlattenTableInputs(dataInputs);

[varargout{1:nargout}] = iSplitApply(fun, gnum, dataInputs{:});

% The main implementation after input argument parsing.
function varargout = iSplitApply(fun, gnum, varargin)
markerFrame = matlab.bigdata.internal.InternalStackFrame(); %#ok<NASGU>

session = matlab.bigdata.internal.splitapply.SplitapplySession(fun);
sessionCleanup = onCleanup(@session.close);

try
    uniqueGnum = unique(gnum);
    [varargin{:}] = iWrapTallAsGroupedTall(gnum, session, varargin{:});
    [varargout{1:nargout}] = iCallFunction(fun, session, varargin{:});
    for ii = 1:numel(varargout)
        varargout{ii} = iParseOutput(varargout{ii}, uniqueGnum, session);
    end
catch err
    matlab.bigdata.internal.util.assertNotInternal(err);
    rethrow(err);
end

% Call the function handle, correctly translating any error message to what
% core splitapply would issue.
function varargout = iCallFunction(fun, session, varargin)
try
    [varargout{1:nargout}] = fun(varargin{:});
catch err
    if isequal(err.identifier, 'MATLAB:bigdata:array:ExecutionError')
        rethrow(err);
    end
    funStr = func2str(session.FunctionHandle);
    idx = 1;
    idx = matlab.internal.datatypes.ordinalString(idx);
    matlab.bigdata.internal.throw(...
        message('MATLAB:splitapply:FunFailed', funStr, idx, err.message));
end

% Parse the output generated by the function handle.
%
% This is to handle both the case where the function handle emits a cell
% array or other non-tall array.
function data = iParseOutput(data, uniqueGnum, session)
if iscell(data)
    data = iParseCellOutput(data);
end

if istall(data) && isa(hGetValueImpl(data), 'matlab.bigdata.internal.splitapply.GroupedPartitionedArray')
    data = iUnWrapGroupedTall(data);
else
    funStr = matlab.bigdata.internal.broadcast(func2str(session.FunctionHandle));
    data = clientfun(@iCreateOutputFromScalar, uniqueGnum, data, funStr);
end

% Parse a cell array output generated by the function handle.
function data = iParseCellOutput(data)
if ~iscell(data)
    return;
end

data = cellfun(@iParseCellOutput, data, 'UniformOutput', false);
if any(cellfun(@istall, data))
    % If the cell array contains any tall arrays, we need to bring the tall
    % attribute up one level so that the cell array is per group.
    data = clientfun(@(sz, varargin) reshape(varargin, sz), size(data), data{:});
end

% Wrap a collection of tall arrays each as a grouped tall array.
function varargout = iWrapTallAsGroupedTall(keys, session, varargin)
import matlab.bigdata.internal.splitapply.GroupedPartitionedArray;
keys = hGetValueImpl(keys);
pv = cellfun(@hGetValueImpl, varargin, 'UniformOutput', false);
[varargout{1:nargout}] = GroupedPartitionedArray.create(keys, session, pv{:});
for ii = 1:numel(varargout)
    varargout{ii} = tall(varargout{ii});
    varargout{ii}.Adaptor = resetTallSize(varargin{ii}.Adaptor);
end

% Unwrap a grouped tall array
function out = iUnWrapGroupedTall(in)
gpv = hGetValueImpl(in);
funStr = matlab.bigdata.internal.broadcast(func2str(gpv.Session.FunctionHandle));
[keys, values] = unwrap(gpv);
out = tall(clientfun(@iCreateOutput, keys, values, funStr));
out.Adaptor = resetTallSize(in.Adaptor);

% Validate and extract the gnum input. This also ensures all non-gnum inputs
% are not singleton in the tall dimension.
function gnum = iExtractGnumAsDouble(varargin)
% All inputs have the same size as per validateSameTallSize above.
sz = size(varargin{1}, 1);

gnum = varargin{end};
gnumIsValid = isnumeric(gnum) && iscolumn(gnum) && all(isnan(gnum) | mod(gnum, 1) == 0 & gnum > 0);
% We set NaN values to hidden group gnum 0. This is so at the end we know
% whether NaN values existed in the input.
gnum(isnan(gnum)) = 0;
if ~gnumIsValid
    % Depending on the partitioning and order of execution, gnum could be invalid
    % either by being a non-scalar row, or a matrix. Here we throw a single
    % error that covers both cases to ensure a consistent error is returned.
    error(message('MATLAB:bigdata:array:SplitApplyUnsupportedGroupNums'));
end
if size(gnum, 1) == 1
    gnum = gnum .* ones(sz, 1);
end

gnum = double(gnum);

% Helper function that flattens all table inputs.
function flattenedInputs = iFlattenTableInputs(inputs)
flattenedInputs = cell(size(inputs));
for inputIndex = 1:numel(inputs)
    if any(strcmp(tall.getClass(inputs{inputIndex}), {'table', 'timetable'}))
        variableNames = subsref(inputs{inputIndex}, ...
                                substruct('.', 'Properties', '.', 'VariableNames'));
        flattenedInputs{inputIndex} = cell(1, numel(variableNames));
        for varIndex = 1:numel(variableNames)
            flattenedInputs{inputIndex}{varIndex} = subsref(inputs{inputIndex}, substruct('.', variableNames{varIndex}));
        end
    else
        flattenedInputs{inputIndex} = inputs(inputIndex);
    end
end
flattenedInputs = [flattenedInputs{:}];

% Create the output from a scalar value. This is for user functions that do
% not return a grouped tall array.
function values = iCreateOutputFromScalar(gnum, values, funStr)
if size(values, 1) ~= 1
    idx = matlab.internal.datatypes.ordinalString(1);
    error(message('MATLAB:bigdata:array:SplitApplyOutputNotUniform', funStr, idx));
end
values = repmat(values, numel(gnum), 1);
values = iCreateOutput(gnum, values, funStr);

% Create the output. This unpacks values into the form expected as the
% output of splitapply, vertical concatenation of groups sorted by key.
function values = iCreateOutput(gnum, values, funStr)
gnum = double(string(gnum));
[gnum, idx] = sort(gnum);
values = matlab.bigdata.internal.util.indexSlices(values, idx);

isNanGroup = (gnum == 0);
if any(isNanGroup)
    gnum(isNanGroup,:) = [];
    values = matlab.bigdata.internal.util.indexSlices(values, ~isNanGroup);
end

expectedGnum = (1:max(gnum))';
if ~isequal(gnum, expectedGnum)
    if ~isempty(setdiff(expectedGnum, gnum))
        error(message('MATLAB:splitapply:MissingGroupNums'));
    else
        idx = gnum(find(gnum(1:max(gnum)) ~= expectedGnum, 1, 'first'));
        if isempty(idx)
            idx = 1;
        end
        idx = matlab.internal.datatypes.ordinalString(idx);
        error(message('MATLAB:bigdata:array:SplitApplyOutputNotUniform', funStr, idx));
    end
end
